{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { ActionTypes } from './useListbox.types';\nconst pageSize = 5;\nfunction findValidOptionToHighlight(index, lookupDirection, options, focusDisabled, isOptionDisabled, wrapAround) {\n  if (options.length === 0 || options.every((o, i) => isOptionDisabled(o, i))) {\n    return -1;\n  }\n  let nextFocus = index;\n  for (;;) {\n    // No valid options found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === options.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n    const nextFocusDisabled = focusDisabled ? false : isOptionDisabled(options[nextFocus], nextFocus);\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n      if (wrapAround) {\n        nextFocus = (nextFocus + options.length) % options.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\nfunction getNewHighlightedOption(options, previouslyHighlightedOption, diff, highlightDisabledOptions, isOptionDisabled, disableListWrap, optionComparer) {\n  var _options$nextIndex;\n  const maxIndex = options.length - 1;\n  const defaultHighlightedIndex = -1;\n  const previouslyHighlightedIndex = previouslyHighlightedOption == null ? -1 : options.findIndex(option => optionComparer(option, previouslyHighlightedOption));\n  let nextIndexCandidate;\n  let lookupDirection;\n  let wrapAround;\n  switch (diff) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n    default:\n      {\n        const newIndex = previouslyHighlightedIndex + diff;\n        wrapAround = !disableListWrap;\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(diff) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(diff) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = diff >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n  const nextIndex = findValidOptionToHighlight(nextIndexCandidate, lookupDirection, options, highlightDisabledOptions, isOptionDisabled, wrapAround);\n  return (_options$nextIndex = options[nextIndex]) != null ? _options$nextIndex : null;\n}\nfunction moveHighlight(previouslyHighlightedOption, diff, props) {\n  const {\n    options,\n    isOptionDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    optionComparer\n  } = props;\n  return getNewHighlightedOption(options, previouslyHighlightedOption, diff, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, disableListWrap != null ? disableListWrap : false, optionComparer != null ? optionComparer : (o1, o2) => o1 === o2);\n}\nfunction toggleSelection(option, selectedOptions, selectionLimit, optionComparer) {\n  if (selectionLimit === 0) {\n    return [];\n  }\n\n  // Selection limit = 1 is a special case - we don't want to allow deselecting the option.\n  if (selectionLimit === 1) {\n    if (optionComparer(selectedOptions[0], option)) {\n      return selectedOptions;\n    }\n    return [option];\n  }\n\n  // The toggled option is selected; remove it from the selection.\n  if (selectedOptions.some(so => optionComparer(so, option))) {\n    return selectedOptions.filter(so => !optionComparer(so, option));\n  }\n\n  // The toggled option is not selected and the selected array is shorter than the limit - add to the selection.\n  if (selectionLimit === null || selectedOptions.length < selectionLimit) {\n    return [...selectedOptions, option];\n  }\n\n  // Truncate the selection to the limit (discard items with lower indexes).\n  const newSelection = selectedOptions.slice(selectedOptions.length - selectionLimit + 1);\n  newSelection.push(option);\n  return newSelection;\n}\nfunction handleOptionSelection(option, state, props) {\n  const {\n    optionComparer = (o, v) => o === v,\n    isOptionDisabled = () => false,\n    selectionLimit\n  } = props;\n  const {\n    selectedValues\n  } = state;\n  const optionIndex = props.options.findIndex(o => props.optionComparer(option, o));\n  if (isOptionDisabled(option, optionIndex)) {\n    return state;\n  }\n\n  // if the option is already selected, remove it from the selection, otherwise add it\n  const newSelectedValues = toggleSelection(option, selectedValues, selectionLimit, optionComparer);\n  return {\n    selectedValues: newSelectedValues,\n    highlightedValue: option\n  };\n}\nfunction handleKeyDown(event, state, parameters) {\n  const previouslySelectedValue = state.highlightedValue;\n  switch (event.key) {\n    case 'Home':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', parameters)\n      });\n    case 'End':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', parameters)\n      });\n    case 'PageUp':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, parameters)\n      });\n    case 'PageDown':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, parameters)\n      });\n    case 'ArrowUp':\n      // TODO: extend current selection with Shift modifier\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, parameters)\n      });\n    case 'ArrowDown':\n      // TODO: extend current selection with Shift modifier\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, parameters)\n      });\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n      return handleOptionSelection(state.highlightedValue, state, parameters);\n    default:\n      break;\n  }\n  return state;\n}\nfunction handleBlur(state) {\n  return _extends({}, state, {\n    highlightedValue: null\n  });\n}\nconst textCriteriaMatches = (nextFocus, searchString, stringifyOption) => {\n  var _stringifyOption;\n  const text = (_stringifyOption = stringifyOption(nextFocus)) == null ? void 0 : _stringifyOption.trim().toLowerCase();\n  if (!text || text.length === 0) {\n    // Make option not navigable if stringification fails or results in empty string.\n    return false;\n  }\n  return text.indexOf(searchString) === 0;\n};\nfunction handleTextNavigation(state, searchString, props) {\n  const {\n    options,\n    isOptionDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    optionComparer,\n    optionStringifier\n  } = props;\n  const startWithCurrentOption = searchString.length > 1;\n  let nextOption = startWithCurrentOption ? state.highlightedValue : getNewHighlightedOption(options, state.highlightedValue, 1, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, disableListWrap != null ? disableListWrap : false, optionComparer);\n\n  // use `for` instead of `while` prevent infinite loop\n  for (let index = 0; index < options.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextOption || !startWithCurrentOption && state.highlightedValue === nextOption) {\n      return state;\n    }\n    if (textCriteriaMatches(nextOption, searchString, optionStringifier) && (!isOptionDisabled(nextOption, options.indexOf(nextOption)) || disabledItemsFocusable)) {\n      // The nextOption is the element to be highlighted\n      return _extends({}, state, {\n        highlightedValue: nextOption\n      });\n    }\n    // Move to the next element.\n    nextOption = getNewHighlightedOption(options, nextOption, 1, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, disableListWrap != null ? disableListWrap : false, optionComparer);\n  }\n\n  // No option match text search criteria\n  return state;\n}\nfunction handleOptionsChange(options, state, props) {\n  var _options$find, _state$selectedValues;\n  const {\n    optionComparer\n  } = props;\n  const newHighlightedOption = state.highlightedValue == null ? null : (_options$find = options.find(option => optionComparer(option, state.highlightedValue))) != null ? _options$find : null;\n\n  // exclude selected values that are no longer in the options\n  const selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];\n  const newSelectedValues = selectedValues.filter(selectedValue => options.some(option => optionComparer(option, selectedValue)));\n  return {\n    highlightedValue: newHighlightedOption,\n    selectedValues: newSelectedValues\n  };\n}\nexport default function defaultListboxReducer(state, action) {\n  const {\n    type\n  } = action;\n  switch (type) {\n    case ActionTypes.keyDown:\n      return handleKeyDown(action.event, state, action.props);\n    case ActionTypes.optionClick:\n      return handleOptionSelection(action.option, state, action.props);\n    case ActionTypes.blur:\n      return handleBlur(state);\n    case ActionTypes.setValue:\n      return _extends({}, state, {\n        selectedValues: action.value\n      });\n    case ActionTypes.setHighlight:\n      return _extends({}, state, {\n        highlightedValue: action.highlight\n      });\n    case ActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, action.props);\n    case ActionTypes.optionsChange:\n      return handleOptionsChange(action.options, state, action.props);\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["_extends","ActionTypes","pageSize","findValidOptionToHighlight","index","lookupDirection","options","focusDisabled","isOptionDisabled","wrapAround","length","every","o","i","nextFocus","nextFocusDisabled","getNewHighlightedOption","previouslyHighlightedOption","diff","highlightDisabledOptions","disableListWrap","optionComparer","_options$nextIndex","maxIndex","defaultHighlightedIndex","previouslyHighlightedIndex","findIndex","option","nextIndexCandidate","newIndex","Math","abs","nextIndex","moveHighlight","props","disabledItemsFocusable","o1","o2","toggleSelection","selectedOptions","selectionLimit","some","so","filter","newSelection","slice","push","handleOptionSelection","state","v","selectedValues","optionIndex","newSelectedValues","highlightedValue","handleKeyDown","event","parameters","previouslySelectedValue","key","handleBlur","textCriteriaMatches","searchString","stringifyOption","_stringifyOption","text","trim","toLowerCase","indexOf","handleTextNavigation","optionStringifier","startWithCurrentOption","nextOption","handleOptionsChange","_options$find","_state$selectedValues","newHighlightedOption","find","selectedValue","defaultListboxReducer","action","type","keyDown","optionClick","blur","setValue","value","setHighlight","highlight","textNavigation","optionsChange"],"sources":["/Users/ash/Desktop/AshProjects/whisperPPT/frontend/node_modules/@mui/base/useListbox/defaultListboxReducer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { ActionTypes } from './useListbox.types';\nconst pageSize = 5;\nfunction findValidOptionToHighlight(index, lookupDirection, options, focusDisabled, isOptionDisabled, wrapAround) {\n  if (options.length === 0 || options.every((o, i) => isOptionDisabled(o, i))) {\n    return -1;\n  }\n  let nextFocus = index;\n  for (;;) {\n    // No valid options found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === options.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n    const nextFocusDisabled = focusDisabled ? false : isOptionDisabled(options[nextFocus], nextFocus);\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n      if (wrapAround) {\n        nextFocus = (nextFocus + options.length) % options.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\nfunction getNewHighlightedOption(options, previouslyHighlightedOption, diff, highlightDisabledOptions, isOptionDisabled, disableListWrap, optionComparer) {\n  var _options$nextIndex;\n  const maxIndex = options.length - 1;\n  const defaultHighlightedIndex = -1;\n  const previouslyHighlightedIndex = previouslyHighlightedOption == null ? -1 : options.findIndex(option => optionComparer(option, previouslyHighlightedOption));\n  let nextIndexCandidate;\n  let lookupDirection;\n  let wrapAround;\n  switch (diff) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n    default:\n      {\n        const newIndex = previouslyHighlightedIndex + diff;\n        wrapAround = !disableListWrap;\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(diff) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(diff) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = diff >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n  const nextIndex = findValidOptionToHighlight(nextIndexCandidate, lookupDirection, options, highlightDisabledOptions, isOptionDisabled, wrapAround);\n  return (_options$nextIndex = options[nextIndex]) != null ? _options$nextIndex : null;\n}\nfunction moveHighlight(previouslyHighlightedOption, diff, props) {\n  const {\n    options,\n    isOptionDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    optionComparer\n  } = props;\n  return getNewHighlightedOption(options, previouslyHighlightedOption, diff, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, disableListWrap != null ? disableListWrap : false, optionComparer != null ? optionComparer : (o1, o2) => o1 === o2);\n}\nfunction toggleSelection(option, selectedOptions, selectionLimit, optionComparer) {\n  if (selectionLimit === 0) {\n    return [];\n  }\n\n  // Selection limit = 1 is a special case - we don't want to allow deselecting the option.\n  if (selectionLimit === 1) {\n    if (optionComparer(selectedOptions[0], option)) {\n      return selectedOptions;\n    }\n    return [option];\n  }\n\n  // The toggled option is selected; remove it from the selection.\n  if (selectedOptions.some(so => optionComparer(so, option))) {\n    return selectedOptions.filter(so => !optionComparer(so, option));\n  }\n\n  // The toggled option is not selected and the selected array is shorter than the limit - add to the selection.\n  if (selectionLimit === null || selectedOptions.length < selectionLimit) {\n    return [...selectedOptions, option];\n  }\n\n  // Truncate the selection to the limit (discard items with lower indexes).\n  const newSelection = selectedOptions.slice(selectedOptions.length - selectionLimit + 1);\n  newSelection.push(option);\n  return newSelection;\n}\nfunction handleOptionSelection(option, state, props) {\n  const {\n    optionComparer = (o, v) => o === v,\n    isOptionDisabled = () => false,\n    selectionLimit\n  } = props;\n  const {\n    selectedValues\n  } = state;\n  const optionIndex = props.options.findIndex(o => props.optionComparer(option, o));\n  if (isOptionDisabled(option, optionIndex)) {\n    return state;\n  }\n\n  // if the option is already selected, remove it from the selection, otherwise add it\n  const newSelectedValues = toggleSelection(option, selectedValues, selectionLimit, optionComparer);\n  return {\n    selectedValues: newSelectedValues,\n    highlightedValue: option\n  };\n}\nfunction handleKeyDown(event, state, parameters) {\n  const previouslySelectedValue = state.highlightedValue;\n  switch (event.key) {\n    case 'Home':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', parameters)\n      });\n    case 'End':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', parameters)\n      });\n    case 'PageUp':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, parameters)\n      });\n    case 'PageDown':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, parameters)\n      });\n    case 'ArrowUp':\n      // TODO: extend current selection with Shift modifier\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, parameters)\n      });\n    case 'ArrowDown':\n      // TODO: extend current selection with Shift modifier\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, parameters)\n      });\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n      return handleOptionSelection(state.highlightedValue, state, parameters);\n    default:\n      break;\n  }\n  return state;\n}\nfunction handleBlur(state) {\n  return _extends({}, state, {\n    highlightedValue: null\n  });\n}\nconst textCriteriaMatches = (nextFocus, searchString, stringifyOption) => {\n  var _stringifyOption;\n  const text = (_stringifyOption = stringifyOption(nextFocus)) == null ? void 0 : _stringifyOption.trim().toLowerCase();\n  if (!text || text.length === 0) {\n    // Make option not navigable if stringification fails or results in empty string.\n    return false;\n  }\n  return text.indexOf(searchString) === 0;\n};\nfunction handleTextNavigation(state, searchString, props) {\n  const {\n    options,\n    isOptionDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    optionComparer,\n    optionStringifier\n  } = props;\n  const startWithCurrentOption = searchString.length > 1;\n  let nextOption = startWithCurrentOption ? state.highlightedValue : getNewHighlightedOption(options, state.highlightedValue, 1, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, disableListWrap != null ? disableListWrap : false, optionComparer);\n\n  // use `for` instead of `while` prevent infinite loop\n  for (let index = 0; index < options.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextOption || !startWithCurrentOption && state.highlightedValue === nextOption) {\n      return state;\n    }\n    if (textCriteriaMatches(nextOption, searchString, optionStringifier) && (!isOptionDisabled(nextOption, options.indexOf(nextOption)) || disabledItemsFocusable)) {\n      // The nextOption is the element to be highlighted\n      return _extends({}, state, {\n        highlightedValue: nextOption\n      });\n    }\n    // Move to the next element.\n    nextOption = getNewHighlightedOption(options, nextOption, 1, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, disableListWrap != null ? disableListWrap : false, optionComparer);\n  }\n\n  // No option match text search criteria\n  return state;\n}\nfunction handleOptionsChange(options, state, props) {\n  var _options$find, _state$selectedValues;\n  const {\n    optionComparer\n  } = props;\n  const newHighlightedOption = state.highlightedValue == null ? null : (_options$find = options.find(option => optionComparer(option, state.highlightedValue))) != null ? _options$find : null;\n\n  // exclude selected values that are no longer in the options\n  const selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];\n  const newSelectedValues = selectedValues.filter(selectedValue => options.some(option => optionComparer(option, selectedValue)));\n  return {\n    highlightedValue: newHighlightedOption,\n    selectedValues: newSelectedValues\n  };\n}\nexport default function defaultListboxReducer(state, action) {\n  const {\n    type\n  } = action;\n  switch (type) {\n    case ActionTypes.keyDown:\n      return handleKeyDown(action.event, state, action.props);\n    case ActionTypes.optionClick:\n      return handleOptionSelection(action.option, state, action.props);\n    case ActionTypes.blur:\n      return handleBlur(state);\n    case ActionTypes.setValue:\n      return _extends({}, state, {\n        selectedValues: action.value\n      });\n    case ActionTypes.setHighlight:\n      return _extends({}, state, {\n        highlightedValue: action.highlight\n      });\n    case ActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, action.props);\n    case ActionTypes.optionsChange:\n      return handleOptionsChange(action.options, state, action.props);\n    default:\n      return state;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}